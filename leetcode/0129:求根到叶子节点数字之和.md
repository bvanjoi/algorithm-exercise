# 题目地址

https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/

# 题目描述：求根到叶子节点数字之和

给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1->2->3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明: 叶子节点是指没有子节点的节点。

示例：
>例 1:
>
>输入: [1,2,3]
>```
>    1
>   / \
>  2   3
>```
>输出: 25
>
>解释：从根到叶子节点路径 1->2 代表数字 12. 从根到叶子节点路径 1->3 代表数字 13. 因此，数字总和 = 12 + 13 = 25.
>
>例 2:
>
>输入: [4,9,0,5,1]
>```
>    4
>   / \
>  9   0
> / \
>5   1
>```
>输出: 1026
>
>解释：从根到叶子节点路径 4->9->5 代表数字 495. 从根到叶子节点路径 4->9->1 代表数字 491. 从根到叶子节点路径 4->0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026.


# 解答
很简单，层次遍历即可。

每层结点的值均加上上一层结点的十倍，当到达叶子结点时，将数值添加到结果中即可。

代码：
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        if( !root)
            return 0;
        
        int res = 0;
        //层次遍历更新结点
        queue<TreeNode*> record;
        record.push( root);
        while( !record.empty()){
            int count = record.size();
            while( count--){
                TreeNode* temp = record.front();
                record.pop();
                if( temp->left) temp->left->val += temp->val * 10 ,record.push( temp->left);
                if( temp->right) temp->right->val += temp->val * 10 ,record.push( temp->right);
                if( !temp->left && !temp->right)
                    res += temp->val;
            }
        }
        return res;
    }
};
```
