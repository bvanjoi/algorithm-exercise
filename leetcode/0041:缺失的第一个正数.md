# 题目地址

https://leetcode-cn.com/problems/first-missing-positive/

# 题目描述：缺失的第一个正数

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例：
>例 1:
>
>输入: [1,2,0]
>
>输出: 3
>
>例 2:
>
>输入: [3,4,-1,1]
>
>输出: 2
>
>例 3:
>
>输入: [7,8,9,11,12]
>
>输出: 1


说明:你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

# 解答

这道题的难度在于时间和空间的限制。

若没有时间的限制，可以直接排序后遍历查找。

若没有空间的限制，可以创建辅助空间后记录。

现在要求线性时间与常数空间，因此上述两种方法不能使用。

我们采取以下方法：用自身当作 hashmap.

首先，由于需要查找的是缺失的第一个正数，因此我们将所有的非正数全部处理掉。其方法是对于每一个正数元素，将它向前移动 count 个位置，count 为当前位置前非正数元素的个数，类似于 [删除排序数组中的重复项](/leetcode_src/0026:删除排序数组中的重复项.md). 

之后，在有效的长度内的元素均为正数。

接着，遍历数组，对于每一个元素 nums[i]，我们将它对应的下标位置，即 nums[ abs(nums[i])] 标记为负值，证明该正数出现过。（在代码中，出于细节考虑，将其对应位置再减 1）.

例如：[1,2,10], 当目前位于下标 0 处时，其元素值为 nums[0] = 1, 我们将下标为 1 处的元素，即 2, 标记为 -2, 以此来证明 1 出现过。

当位于下标 1 时，其元素值为 nums[1] = -2, 我们将下标为 2 处的元素，即 3, 标记为 -3, 以此来证明正数 2 出现过。

一个需要注意的细节是，若当前位置的元素值的绝对值大于数组有效长度，该如何处理？

答案很简单：直接略过。考虑数组 [4,5,6], 每个元素均大于数组的有效长度，这意味着比他们小的正数都没出现过，因此不需要处理。

最后遍历数组，若当前元素值大于 0, 则证明该位置对应的下标没出现过，返回该值即可。

代码：
```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        //首先处理所有的非正数
        int count = 0;
        for( int i = 0; i < nums.size(); i++){
            if( nums[i] <= 0)
                count++;
            else
                nums[i - count] = nums[i];
        }
         
        //此时前 nums.size() - count 均为正数
        for( int i = 0; i < nums.size() - count; i++){
            int now_index = abs(nums[i]) - 1;   // 减1 的目的是为了与下标对齐
            if( now_index >= nums.size() - count)
                ;
            else
                nums[ now_index] = (-1)* abs( nums[ now_index]);
        }
            
        //寻找最小的未出现的正数
        int i = 0;
        for( ; i < nums.size() - count; i++)
            if( nums[i] > 0) 
                return i + 1;
      
        return i + 1;
    }
};
```

