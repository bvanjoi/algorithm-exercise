# 题目地址
https://leetcode-cn.com/problems/search-in-rotated-sorted-array/

# 题目描述：搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中**不存在**重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

示例：

>例 1:
>
>输入: nums = [4,5,6,7,0,1,2], target = 0
>
>输出: 4
>
>例 2:
>
>输入: nums = [4,5,6,7,0,1,2], target = 3
>
>输出: -1



# 解答

算法可以分为两部分：若未旋转，则二分查找；若旋转，则处理边界。

未旋转时，target 必定位于 [left, ..., right] 之间，依据 nums[middle] 与 target 的值二分即可。

旋转时，可能存在两种情况：左侧 [left, ... middle] 发生旋转、右侧 [middle, right] 发生旋转。通过检查 target 与三个端点处的大小关系，进行区间选择。

代码：
```cpp
class Solution {
public:
    //算法复杂度限制在对数时间
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while( left < (int)right){
            int middle = left + (right - left) / 2;
            
            if( nums[left] < nums[right]){  //此时未发生旋转，直接按照二分查找即可    
                if( nums[ middle] == target)
                    return middle;
                else if( nums[ middle] < target)
                    left = middle + 1;
                else
                    right = middle;
            }
            else{   //此时[left, right]发生旋转
                if( nums[left] <= nums[middle]){ //[left, middle] 未旋转
                    if( target < nums[left] || target > nums[middle])
                        left = middle + 1;
                    else 
                        right = middle;
                }  
                else if( nums[middle] <= nums[right]){  //[middle, right]未旋转
                    if( target < nums[middle] || target > nums[right])
                        right = middle - 1;
                    else
                        left = middle;
                }    
            }
        }
        
        if( left < nums.size() && nums[left] == target)
            return left;
        return -1;
    }
};
```
